{-# LANGUAGE GADTs #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeFamilyDependencies #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE ImplicitParams #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE ConstraintKinds #-}
{-# LANGUAGE UndecidableSuperClasses #-}
{-# LANGUAGE AllowAmbiguousTypes #-}

module Data.Resource where

import GHC.TypeLits
import Data.IORef
import Data.Proxy
import Control.Monad
import Control.Monad.IO.Class
import Control.Exception.Safe

-- ------------------------------------------------------------
-- Resources
-- ------------------------------------------------------------

-- | Represents a context used in IO action accessing resource.
-- Every context is generated by the resource and closed at the end of the action.
class (Resource (ResourceType c), ContextType (ResourceType c) ~ c) => ResourceContext c where
    -- | The type of resource which generates this context.
    type ResourceType c :: *

    -- | This method is invoked when the IO action finished or some exception is thrown.
    -- Instance type should implement releasing operation of resource handles if @execContext@ does not do it.
    closeContext :: (Monad m, MonadIO m)
                 => c -- ^ This context.
                 -> Bool -- ^ Denotes whether the action finished without exception.
                 -> m c -- ^ Closed context.

    -- | Executes an IO action and returns the result.
    execContext :: (Monad m, MonadIO m)
                => c -- ^ This context.
                -> m a -- ^ An IO action.
                -> m a -- ^ The result of the action.

-- | Represents a resource to be managed in the application.
-- Every resource is used through a context generated in each execution of IO action.
class (ResourceContext (ContextType r), ResourceType (ContextType r) ~ r) => Resource r where
    -- | The type of context.
    type ContextType r :: *

    -- | Generate a context. The context is contained in IORef, thus, it can be modified in IO action.
    newContext :: (Monad m, MonadIO m)
               => r -- ^ This resource.
               -> m (IORef (ContextType r)) -- ^ Generate context contained in IORef.

class (Resource r) => ResourceFactory rf r where
    newResource :: (Monad m, MonadIO m) => rf -> m (IORef r)

data Resources (rs :: [*]) where
    RNil :: Resources '[]

    RCons :: (Resource r)
          => IORef r
          -> Resources rs
          -> Resources (IORef r ': rs)

infixr 5 `RCons`

class ResourceOf r rs where
    resourceOf :: Resources rs -> IORef r

instance ResourceOf r (IORef r ': rs) where
    resourceOf (v `RCons` vs) = v

instance {-# OVERLAPPABLE #-} (ResourceOf r rs) => ResourceOf r (x ': rs) where
    resourceOf (v `RCons` vs) = resourceOf vs

-- ------------------------------------------------------------
-- Contexts
-- ------------------------------------------------------------

data Contexts (cs :: [*]) where
    CNil :: Contexts '[]

    CCons :: (ResourceContext c)
          => IORef c
          -> Contexts cs
          -> Contexts (IORef c ': cs)

infixr 5 `CCons`

execute :: (Monad m, MonadIO m, ExecContexts cs)
        => Contexts (Refs cs)
        -> (With cs => m a)
        -> m a
execute contexts f = execContexts contexts contexts f

class ExecContexts cs where
    execContexts :: (Monad m, MonadIO m)
                 => Contexts (Refs cs')
                 -> Contexts (Refs cs)
                 -> (With cs' => m a)
                 -> m a

instance ExecContexts '[] where
    execContexts contexts _ f = let ?cxt = contexts in f

instance (ExecContexts cs) => ExecContexts (c ': cs) where
    execContexts contexts (cxt `CCons` cxts) f = do
        cxt' <- liftIO $ readIORef cxt
        execContext cxt' $ execContexts contexts cxts f

closeAll :: (Monad m, MonadIO m)
         => Bool
         -> Contexts cs
         -> m ()
closeAll b CNil = return ()
closeAll b (v `CCons` vs) = do
    c <- liftIO $ readIORef v
    closeContext c b >>= liftIO . writeIORef v
    closeAll b vs

class ContextOf c cs where
    contextOf :: Contexts cs -> IORef c

instance ContextOf c (IORef c ': cs) where
    contextOf (v `CCons` vs) = v

instance {-# OVERLAPPABLE #-} (cs ~ (x ': cs'), ContextOf c cs') => ContextOf c cs where
    contextOf (v `CCons` vs) = contextOf vs

class ContextResources (cs :: [*]) rs where
    generateContexts :: (Monad m, MonadIO m) => Resources rs -> m (Contexts cs)

instance ContextResources '[] rs where
    generateContexts _ = return CNil

instance (ResourceContext c, ResourceOf (ResourceType c) rs, ContextResources cs rs) => ContextResources (IORef c ': cs) rs where
    generateContexts resources = do
        r <- liftIO $ readIORef (resourceOf @(ResourceType c) resources)
        cxt <- newContext r
        others <- generateContexts @cs resources
        return $ cxt `CCons` others

type family Refs (as :: [*]) = (rs :: [*]) | rs -> as
type instance Refs '[] = '[]
type instance Refs (a ': as) = IORef a ': Refs as

type With (cs :: [*]) = (?cxt :: Contexts (Refs cs))

withContext :: forall cs rs m a. (ExecContexts cs, ContextResources (Refs cs) rs, Monad m, MonadIO m, MonadMask m)
            => Resources rs
            -> (With cs => m a)
            -> m (a, Contexts (Refs cs))
withContext resources f = do
    bracketOnError (generateContexts @(Refs cs) resources)
                   (closeAll False)
                   (\c -> do
                        r <- execute c f
                        closeAll True c
                        return (r, c)
                    )
